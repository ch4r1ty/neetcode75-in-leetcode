所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！

遞歸三部曲：
1. 傳入參數和返回類型：
    每一個path，保存所有path的res，當前節點node

2. 終止條件
    當當前節點是葉子節點的時候，開始終止的邏輯：把路徑放到res裏
    所以本题的终止条件是：
    ```java
    if (cur->left == NULL && cur->right == NULL) {
    终止处理逻辑
    }
    ```
    在這裏，之前的終止處理邏輯，都是 return null, return 0, 但是其實，這些只是處理邏輯的一種。

    本體的處理邏輯，path的構成，是有一個完整路徑的時候（還沒有->符號時），把path拼接成有->符號的路徑，作爲一個path。
    也就是，遇到葉子節點，再開始構建一個帶->的path

3. 單層遞歸邏輯
    這裏是前序遍歷，很可以理解因爲要保存path，而path是從上往下的，所以要中左右，中在最前面（中在上一層）
    遞歸邏輯，和2.中的終止處理邏輯是不同的。遞歸邏輯，是怎樣去進行遞歸；終止邏輯，是每一層的處理邏輯


# 二叉树递归条件对比总结

## 🚨 错误写法 vs 正确写法

### ❌ 错误写法
```java
if (node.left == null) {
    traverse(path, res, node.right);
    path.remove(path.size() - 1);
}
if (node.right == null) {
    traverse(path, res, node.left);
    path.remove(path.size() - 1);
}
```

### ✅ 正确写法
```java
if (node.left != null) {
    traverse(path, res, node.left);
    path.remove(path.size() - 1);
}
if (node.right != null) {
    traverse(path, res, node.right);
    path.remove(path.size() - 1);
}
```

## 📊 场景对比分析

### 场景1：完整二叉树 `1->2,3`
| 写法 | node.left | node.right | 执行结果 |
|------|-----------|------------|----------|
| **错误** | 2 (存在) | 3 (存在) | 两个if都是false → **不访问任何子树** |
| **正确** | 2 (存在) | 3 (存在) | 两个if都是true → **访问两个子树** |

### 场景2：只有左子树 `1->2`
| 写法 | node.left | node.right | 执行结果 |
|------|-----------|------------|----------|
| **错误** | 2 (存在) | null | 第二个if为true → **访问左子树** |
| **正确** | 2 (存在) | null | 第一个if为true → **访问左子树** |

### 场景3：叶子节点 `1`
| 写法 | node.left | node.right | 执行结果 |
|------|-----------|------------|----------|
| **错误** | null | null | 两个if都是true → **访问两个null节点（崩溃）** |
| **正确** | null | null | 两个if都是false → **不访问（正确）** |

## 💡 核心区别

### 错误逻辑思维：
- "如果左边没有，就去右边"
- "如果右边没有，就去左边"
- **问题**：两边都有时什么都不做，两边都没有时都去访问

### 正确逻辑思维：
- "如果左边存在，就访问左边"
- "如果右边存在，就访问右边"
- **优点**：存在就处理，不存在就跳过

## 🎯 记忆要点

**递归的黄金法则：存在就处理，不存在就跳过**

```java
// 永远记住这个模式
if (node.left != null) {
    // 处理左子树
}
if (node.right != null) {
    // 处理右子树  
}
```