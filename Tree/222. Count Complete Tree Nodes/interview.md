# Count Complete Tree Nodes - 面试讲稿

## 问题理解
"好的，让我先理解一下这道题。题目要求我们计算一个完全二叉树的节点总数。完全二叉树的特点是：除了最后一层，其他层都是满的，而且最后一层的节点都靠左排列。这个特点很重要，我们后面会用到。"

## 解题思路
"我的思路是这样的：
首先，我们可以用暴力解法，就是遍历整个树，统计所有节点。但是这样时间复杂度是 O(n)，我觉得可以做得更好。

因为这是一个完全二叉树，我们可以利用它的特性来优化。对于任意一个节点，如果它的左子树和右子树的深度相同，那么以这个节点为根的子树就是一个满二叉树。满二叉树的节点数我们可以直接用公式计算：2^h - 1，其中 h 是树的高度。

如果左右子树深度不同，那我们就递归计算左右子树的节点数，再加上当前节点。"

## 代码实现
"让我来实现这个思路：

```java
class Solution {
    public int countNodes(TreeNode root) {
        // 首先处理空树的情况
        if (root == null) return 0;
        
        // 计算左子树的深度
        int leftDepth = 0;
        TreeNode left = root.left;
        while (left != null) {
            left = left.left;
            leftDepth++;
        }
        
        // 计算右子树的深度
        int rightDepth = 0;
        TreeNode right = root.right;
        while (right != null) {
            right = right.right;
            rightDepth++;
        }
        
        // 如果左右子树深度相同，说明是满二叉树
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1;  // 2^(leftDepth+1) - 1
        }
        
        // 否则递归计算
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

## 复杂度分析
"让我分析一下这个解法的时间和空间复杂度：

时间复杂度是 O(log²n)。因为：
- 每次递归都会减少一半的节点
- 计算深度需要 O(log n) 时间
- 总共有 O(log n) 层递归

空间复杂度是 O(log n)，主要是递归调用栈的深度。"

## 优化考虑
"这个解法比暴力解法要好，因为：
1. 对于满二叉树的部分，我们可以直接计算，不需要遍历
2. 我们利用了完全二叉树的特性，避免了不必要的计算
3. 使用位运算来优化计算，比如用 2 << leftDepth 代替 Math.pow"

## 测试用例
"我们可以用这些测试用例来验证代码：
1. 空树：应该返回 0
2. 只有一个节点的树：应该返回 1
3. 完全二叉树：比如 [1,2,3,4,5,6]，应该返回 6
4. 不完全二叉树：比如 [1,2,3,4]，应该返回 4"

## 实际应用
"这个问题在实际中很有用，比如：
1. 数据库的索引结构
2. 堆排序
3. 优先队列的实现"

## 可能的改进
"如果面试官问如何改进，我们可以考虑：
1. 使用迭代而不是递归，减少栈空间使用
2. 对于非常大的树，可以考虑并行计算
3. 如果内存有限，可以考虑使用位图来存储节点信息"

## 总结
"总的来说，这道题考察了：
1. 对树结构的理解
2. 递归思维
3. 数学推导能力
4. 代码实现能力
5. 优化思维

我的解法利用了完全二叉树的特性，通过计算子树深度来判断是否为满二叉树，从而优化了计算过程。这个解法的时间复杂度是 O(log²n)，空间复杂度是 O(log n)。"
