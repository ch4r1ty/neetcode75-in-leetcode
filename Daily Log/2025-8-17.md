# 二叉树题目总结

## BFS层序遍历模板
```python
def bfs(root):
    if not root:
        return []
    
    queue = collections.deque([root])
    result = []
    
    while queue:
        level = []
        for i in range(len(queue)):  # 关键：固定当前层节点数
            cur = queue.popleft()
            level.append(cur.val)
            if cur.left: queue.append(cur.left)
            if cur.right: queue.append(cur.right)
        result.append(level)
    
    return result
```
bfs的模板題。res, level, queue
**口诀：「队、层、弹、存」**

---

## 题目解法

### 199. 二叉树右视图
```python
# 基于BFS模板，只保存每层最后一个
if i == len(queue) - 1:
    res.append(cur.val)
```

### 1161. 层和最大值
```python
# 基于BFS模板，累加每层的和
level_sum = 0  # 每层重置
for i in range(len(queue)):
    level_sum += cur.val
```

### 297. 序列化/反序列化
```python
class Codec:
    def serialize(self, root):
        def dfs(node):
            if not node:
                vals.append("None")
                return
            vals.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        
        vals = []
        dfs(root)
        return ','.join(vals)
    
    def deserialize(self, data):
        def dfs():
            nonlocal index
            if vals[index] == 'None':
                index += 1
                return None
            
            node = TreeNode(int(vals[index]))
            index += 1
            node.left = dfs()   # 按相同顺序重建
            node.right = dfs()
            return node
        
        vals = data.split(',')
        index = 0
        return dfs()
```
# Python字符串split和join方法详解

## `split()` 方法 - 字符串转列表

### 语法
```python
字符串.split('分隔符')
```

### 作用
**把字符串按指定分隔符切分成列表**

### 示例
```python
# 基本用法
data = "1,2,None,None,3"
vals = data.split(',')
print(vals)  # ['1', '2', 'None', 'None', '3']

# 其他分隔符
text = "apple-banana-orange"
fruits = text.split('-')
print(fruits)  # ['apple', 'banana', 'orange']

# 按空格分割
sentence = "hello world python"
words = sentence.split(' ')
print(words)  # ['hello', 'world', 'python']

# 不指定分隔符（默认按空白字符分割）
text = "a b c"
result = text.split()
print(result)  # ['a', 'b', 'c']
```

---

## `join()` 方法 - 列表转字符串

### 语法
```python
'分隔符'.join(列表)
```

### 作用
**把列表中的元素用指定分隔符连接成字符串**

### 示例
```python
# 基本用法
vals = ['1', '2', 'None', 'None', '3']
data = ','.join(vals)
print(data)  # "1,2,None,None,3"

# 其他分隔符
fruits = ['apple', 'banana', 'orange']
text = '-'.join(fruits)
print(text)  # "apple-banana-orange"

# 用空格连接
words = ['hello', 'world', 'python']
sentence = ' '.join(words)
print(sentence)  # "hello world python"

# 无分隔符连接
letters = ['a', 'b', 'c']
result = ''.join(letters)
print(result)  # "abc"
```

---

## 在二叉树序列化中的应用

### 序列化过程
```python
# 1. 收集节点值到列表
vals = []
dfs(root)  # vals = ['1', '2', 'None', 'None', '3', '4', 'None', 'None', '5', 'None', 'None']

# 2. 用逗号连接成字符串
return ','.join(vals)  # "1,2,None,None,3,4,None,None,5,None,None"
```

### 反序列化过程
```python
# 1. 输入字符串
data = "1,2,None,None,3,4,None,None,5,None,None"

# 2. 按逗号分割成列表
vals = data.split(',')  # ['1', '2', 'None', 'None', '3', '4', 'None', 'None', '5', 'None', 'None']

# 3. 遍历列表重建树
```

---

## 记忆技巧

### `split()` - 分割
- **"split"** = 分裂、切分
- 字符串 → 列表
- `"a,b,c".split(',')` → `['a', 'b', 'c']`

### `join()` - 连接  
- **"join"** = 加入、连接
- 列表 → 字符串
- `','.join(['a', 'b', 'c'])` → `"a,b,c"`

### 对称关系
```python
# 互为逆操作
original = "1,2,3"
list_form = original.split(',')    # ['1', '2', '3']
back_to_string = ','.join(list_form)  # "1,2,3"
```

---

## 常见用法总结

| 方法 | 输入 | 输出 | 用途 |
|------|------|------|------|
| `split(',')` | `"a,b,c"` | `['a','b','c']` | 解析CSV、序列化数据 |
| `','.join()` | `['a','b','c']` | `"a,b,c"` | 生成CSV、序列化数据 |
| `split(' ')` | `"hello world"` | `['hello','world']` | 分词处理 |
| `' '.join()` | `['hello','world']` | `"hello world"` | 句子重组 |

### 700. BST搜索
```python
def searchBST(root, val):
    if not root: return None
    if root.val == val: return root
    elif root.val > val: return searchBST(root.left, val)  # 必须return
    else: return searchBST(root.right, val)
```

### 450. BST删除
```python
def deleteNode(root, key):
    if not root: return None
    
    if key < root.val:
        root.left = deleteNode(root.left, key)   # 重新连接
    elif key > root.val:
        root.right = deleteNode(root.right, key)
    else:
        # 4种情况：无子/左子/右子/双子
        if not root.left: return root.right
        if not root.right: return root.left
        # 双子：左树挂到右树最左节点
        temp = root.right
        while temp.left: temp = temp.left
        temp.left = root.left
        return root.right
    
    return root
```

---

## 核心原则

### 递归黄金法则
**需要子问题结果 → 必须return递归调用**

### 树修改原则  
**改树必重连，有果必return**

### 常见错误
- 忘记return递归结果
- 忘记重新连接：`root.left = deleteNode(...)`
- 类方法调用忘记`self.`